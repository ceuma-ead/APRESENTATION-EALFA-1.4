// __     ___     _                     _____ _ _ _            
// \ \   / (_)___(_) ___   ___  _ __   |  ___(_) | |_ ___ _ __ 
//  \ \ / /| |_  / |/ _ \ / _ \| '_ \  | |_  | | | __/ _ \ '__|
//   \ V / | |/ /| | (_) | (_) | | | | |  _| | | | ||  __/ |   
//    \_/  |_/___|_|\___/ \___/|_| |_| |_|   |_|_|\__\___|_|   
//                                                           
//  - V:0.0.1
//  - Plugin Desenvolvido : Daniel EstevÃ£o Martins Mendes
//  - License: Ceuma Corporation
//  - Auth: 23iwe924u

class FilterVision {
    static instances = {};

    constructor(containerId, config = {}) {
        if (config.instanceId) {
            const existingInstance = FilterVision.instances[config.instanceId];
            if (existingInstance) {
                existingInstance.updateConfig(config);
                existingInstance.show();
                return existingInstance;
            }
            FilterVision.instances[config.instanceId] = this;
        }

        this.container = document.getElementById(containerId);
        this.fields = config.fields || [];
        this.position = config.position || 'center';
        this.instanceId = config.instanceId;
        this.events = {};
        this.values = {};
        this.hasEvents = false;
        this.init();
    }

    init() {
        this.createFilter();
        setTimeout(() => {
            this.positionFilter();
            this.setupDrag();
            this.setupEvents();
            this.preventClosing();
        }, 0);
    }

    preventClosing() {
        this.filter.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        this.filter.querySelectorAll('input, select').forEach(element => {
            ['click', 'input', 'change', 'blur'].forEach(event => {
                element.addEventListener(event, (e) => e.stopPropagation());
            });
        });
    }

    updateConfig(config) {
        this.fields = config.fields || this.fields;
        this.position = config.position || this.position;
        
        if (config.fields) {
            this.updateFields();
        }

        // Sempre reposiciona ao atualizar
        setTimeout(() => {
            this.positionFilter();
        }, 0);

        return this;
    }

    updateFields() {
        const form = this.filter.querySelector('.filterVision-form');
        form.innerHTML = '';
        this.fields.forEach(field => {
            form.appendChild(this.createField(field));
        });
        this.setupEvents();
    }

    static getInstance(instanceId) {
        return FilterVision.instances[instanceId];
    }

    static destroyInstance(instanceId) {
        const instance = FilterVision.instances[instanceId];
        if (instance) {
            instance.destroy();
            delete FilterVision.instances[instanceId];
        }
    }

    on(eventName, fieldName, callback) {
        if (!this.events[eventName]) {
            this.events[eventName] = {};
        }
        if (!this.events[eventName][fieldName]) {
            this.events[eventName][fieldName] = [];
        }
        this.events[eventName][fieldName].push(callback);
        return this;
    }

    off(eventName, fieldName) {
        if (this.events[eventName] && this.events[eventName][fieldName]) {
            delete this.events[eventName][fieldName];
        }
        return this;
    }

    trigger(eventName, fieldName, value) {
        if (this.events[eventName]?.[fieldName]) {
            this.events[eventName][fieldName].forEach(callback => callback(value));
        }
    }

    createField(field) {
        const wrapper = document.createElement('div');
        wrapper.className = 'filterVision-field';
        
        if (field.type === 'select') {
            wrapper.innerHTML = `
                <select class="filterVision-select" data-field="${field.name}">
                    ${field.options.map(opt => 
                        `<option value="${opt.value}">${opt.label}</option>`
                    ).join('')}
                </select>
            `;
        } else {
            wrapper.innerHTML = `
                <input 
                    class="filterVision-input" 
                    type="${field.type || 'text'}"
                    placeholder="${field.placeholder || ''}"
                    data-field="${field.name}"
                >
            `;
        }
        
        return wrapper;
    }

    createFilter() {
        const filter = document.createElement('div');
        filter.className = 'filterVision';
        filter.dataset.filterId = this.instanceId;
        filter.innerHTML = `
            <div class="filterVision-header">
                <h3>Filtro <i data-lucide="filter"></i></h3>
                <button class="btn-close filterVision-close" aria-label="Close"></button>
            </div>
            <div class="filterVision-form"></div>
        `;

        const form = filter.querySelector('.filterVision-form');
        this.fields.forEach(field => {
            form.appendChild(this.createField(field));
        });

        this.container.appendChild(filter);
        this.filter = filter;
    }

    setupEvents() {
        this.filter.querySelector('.filterVision-close').onclick = (e) => {
            e.stopPropagation();
            this.hide();
        };
        
        const inputs = this.filter.querySelectorAll('input, select');
        inputs.forEach(input => {
            const fieldName = input.dataset.field;
            
            ['input', 'change', 'blur'].forEach(eventType => {
                input.addEventListener(eventType, (e) => {
                    e.stopPropagation();
                    this.values[fieldName] = e.target.value;
                    this.trigger(eventType, fieldName, e.target.value);
                });
            });
        });
    }

    setupDrag() {
        let isDragging = false;
        let currentX = 0, currentY = 0;
        let initialX = 0, initialY = 0;

        const header = this.filter.querySelector('.filterVision-header');
        
        header.onmousedown = (e) => {
            if (e.target.closest('.filterVision-close')) return;
            
            e.stopPropagation();
            isDragging = true;
            
            const transform = window.getComputedStyle(this.filter).transform;
            const matrix = new DOMMatrixReadOnly(transform);
            currentX = matrix.m41;
            currentY = matrix.m42;
            
            initialX = e.clientX - currentX;
            initialY = e.clientY - currentY;
            
            this.filter.style.cursor = 'grabbing';
        };

        document.onmousemove = (e) => {
            if (!isDragging) return;

            e.preventDefault();
            e.stopPropagation();

            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;

            const bounds = this.container.getBoundingClientRect();
            const filterBounds = this.filter.getBoundingClientRect();

            currentX = Math.min(Math.max(0, currentX), bounds.width - filterBounds.width);
            currentY = Math.min(Math.max(0, currentY), bounds.height - filterBounds.height);

            requestAnimationFrame(() => {
                this.filter.style.transform = `translate(${currentX}px, ${currentY}px)`;
            });
        };

        document.onmouseup = () => {
            isDragging = false;
            this.filter.style.cursor = 'grab';
        };
    }

    positionFilter() {
        const containerRect = this.container.getBoundingClientRect();
        const filterRect = this.filter.getBoundingClientRect();
        let x = 0, y = 0;

        switch(this.position) {
            case 'center':
                x = (containerRect.width - filterRect.width) / 2;
                y = (containerRect.height - filterRect.height) / 2;
                break;
            case 'left':
                x = 10;
                y = (containerRect.height - filterRect.height) / 2;
                break;
            case 'right':
                x = containerRect.width - filterRect.width - 10;
                y = (containerRect.height - filterRect.height) / 2;
                break;
            case 'top':
                x = (containerRect.width - filterRect.width) / 2;
                y = 10;
                break;
            case 'bottom':
                x = (containerRect.width - filterRect.width) / 2;
                y = containerRect.height - filterRect.height - 10;
                break;
            case 'top-left':
                x = 10;
                y = 10;
                break;
            case 'top-right':
                x = containerRect.width - filterRect.width - 10;
                y = 10;
                break;
            case 'bottom-left':
                x = 10;
                y = containerRect.height - filterRect.height - 10;
                break;
            case 'bottom-right':
                x = containerRect.width - filterRect.width - 10;
                y = containerRect.height - filterRect.height - 10;
                break;
        }

        requestAnimationFrame(() => {
            this.filter.style.transform = `translate(${x}px, ${y}px)`;
        });
    }

    updateLabel(fieldName, newLabel) {
        const field = this.filter.querySelector(`[data-field="${fieldName}"]`);
        if (field) {
            field.placeholder = newLabel;
        }
        return this;
    }

    destroy() {
        document.onmousemove = null;
        document.onmouseup = null;
        this.filter.remove();
        this.events = {};
        this.values = {};
        if (this.instanceId) {
            delete FilterVision.instances[this.instanceId];
        }
    }

    show() {
        this.filter.classList.add('active');
        setTimeout(() => {
            this.positionFilter();
        }, 0);
        return this;
    }

    hide() {
        this.filter.classList.remove('active');
        return this;
    }

    getValues() {
        return this.values;
    }
}